# -*- mode: org; coding: utf-8; -*-

* Default option
#+BEGIN_SRC emacs-lisp
(setq default-directory "~")
;; inihibit cl warning
(setq byte-compile-warnings '(cl-functions))
(setq inhibit-splash-screen t) 
(setq inhibit-startup-message t)
(fset 'yes-or-no-p 'y-or-n-p)
;; shell scripts
(setq-default sh-basic-offset 2)
(setq-default sh-indentation 2)
;; No need for ~ files when editing
(setq create-lockfiles nil)
;; Don't show native OS scroll bars for buffers because they're redundant
(when (fboundp 'scroll-bar-mode)
  (scroll-bar-mode -1))
(tool-bar-mode -1)
(menu-bar-mode -1)
(global-visual-line-mode)
(setq backup-inhibited t)
;; No cursor blinking
(blink-cursor-mode 0)
#+END_SRC

* Korean language environment
#+BEGIN_SRC emacs-lisp
(global-set-key [(shift space)] 'toggle-input-method)
(set-language-environment "Korean")
(prefer-coding-system 'utf-8)
(setq default-korean-keyboard "3f")
#+END_SRC

* Font setup
#+BEGIN_SRC emacs-lisp
(defun my-font-setup ()
  "Setup English font and harmoning Korean font"
  (add-to-list 'default-frame-alist '(font . "Source Code Pro-11"))
  (set-face-font 'default "Source Code Pro-11")
  ;(add-to-list 'default-frame-alist '(font . "Cascadia Code-11"))
  ;(set-face-font 'default "Cascadia Code-11")
  ;(add-to-list 'default-frame-alist '(font . "Fira Code-10"))
  ;(set-face-font 'default "Fira Code-10")
  ;(add-to-list 'default-frame-alist '(font . "Ubuntu Mono-11"))
  ;(set-face-font 'default "Ubuntu Mono-11")
  ;(add-to-list 'default-frame-alist '(font . "Monaco-10"))
  ;(set-face-font 'default "Monaco-10")
  (set-fontset-font "fontset-default" '(#x1100 . #xffdc)
                    '("HCR Dotum" . "iso10646-1"))
  (set-fontset-font "fontset-default" '(#xe0bc . #xf66e)
                    '("HCR Dotum" . "iso10646-1"))
  (setq face-font-rescale-alist '((".*HCR.*" . 1.1))))

(my-font-setup)
(add-hook 'sever-switch-hook (my-font-setup))
#+END_SRC

* Custom lisp file path setup
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/lisp")
;(load "~/.emacs.d/lisp/my-abbrev.el")
;(require 'diatheke)
#+END_SRC

* Package management setup
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
        ("melpa-stable" . "http://stable.melpa.org/packages/")
        ("melpa". "http://melpa.org/packages/")))
(package-initialize)

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(require 'use-package)

(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

* Theme & Mode line
** color theme
#+BEGIN_SRC emacs-lisp
;(add-to-list 'custom-theme-load-path "~/.emacs.d/themes/")
(use-package atom-one-dark-theme)
(use-package gruvbox-theme)
(use-package solarized-theme)

(load-theme 'gruvbox t)
;(load-theme 'gruvbox-light-soft t)
;(load-theme 'atom-one-dark t)
;(load-theme 'solarized-dark t)
#+END_SRC

** Powerline
#+BEGIN_SRC emacs-lisp
(use-package powerline
  :init
  (setq powerline-default-separator 'wave)
  :config
  (powerline-center-theme))
#+END_SRC

* Completion
#+BEGIN_SRC emacs-lisp
;; Use builtin completion engine
(bind-key* "C-." #'completion-at-point)

; The `vertico' package applies a vertical layout to the minibuffer.
;; It also pops up the minibuffer eagerly so we can see the available
;; options without further interactions.  This package is very fast
;; and "just works", though it also is highly customisable in case we
;; need to modify its behaviour.
(use-package vertico
  :custom
  (vertico-count 22)
  (vertico-cycle t)
  :init
  (vertico-mode))

;; The built-in `savehist-mode' saves minibuffer histories.  Vertico
;; can then use that information to put recently selected options at
;; the top.
(savehist-mode 1)

;; The `marginalia' package provides helpful annotations next to
;; completion candidates in the minibuffer.  The information on
;; display depends on the type of content.  If it is about files, it
;; shows file permissions and the last modified date.  If it is a
;; buffer, it shows the buffer's size, major mode, and the like.
(use-package marginalia
  :config (marginalia-mode))

;; The `orderless' package lets the minibuffer use an out-of-order
;; pattern matching algorithm.  It matches space-separated words or
;; regular expressions in any order.
(use-package orderless
  :custom (completion-styles '(orderless basic)))

;; The `consult' package provides lots of commands that are enhanced
;; variants of basic, built-in functionality.  One of the headline
;; features of `consult' is its preview facility, where it shows in
;; another Emacs window the context of what is currently matched in
;; the minibuffer.
(use-package consult
  :bind (("C-c i"     . consult-imenu)
         ("C-c b"     . consult-project-buffer)
         ("C-x b"     . consult-buffer)
         ("C-c B"     . consult-bookmark)
         ("C-c y"     . consult-yank-pop)
         ("C-x C-f"   . find-file)
         ("C-c C-h a" . describe-symbol)
         ("M-s M-g"   . consult-ripgrep)
         ("M-s M-f"   . consult-find)
         ("M-s M-o"   . consult-outline)
         ("M-s M-l"   . consult-line)))

;; The `embark' package lets you target the thing or context at point
;; and select an action to perform on it.  Use the `embark-act'
;; command while over something to find relevant commands.
;;
;; When inside the minibuffer, `embark' can collect/export the
;; contents to a fully fledged Emacs buffer.  The `embark-collect'
;; command retains the original behaviour of the minibuffer, meaning
;; that if you navigate over the candidate at hit RET, it will do what
;; the minibuffer would have done.  In contrast, the `embark-export'
;; command reads the metadata to figure out what category this is and
;; places them in a buffer whose major mode is specialised for that
;; type of content.  For example, when we are completing against
;; files, the export will take us to a `dired-mode' buffer; when we
;; preview the results of a grep, the export will put us in a
;; `grep-mode' buffer.
;;
(use-package embark
  :ensure t
  :bind (("C-." . embark-act)
         :map minibuffer-local-map
         ("C-c C-c" . embark-collect)
         ("C-c C-e" . embark-export)))

;; The `embark-consult' package is glue code to tie together `embark'
;; and `consult'.
(use-package embark-consult :after (embark consult))
#+END_SRC

* Navigation: 
** projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile)
(projectile-mode +1)
(define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
(projectile-global-mode)
#+END_SRC

** ace-jump-mode
#+BEGIN_SRC emacs-lisp
;; quick jump in a screen
(use-package ace-jump-mode 
  :bind ("C-." . ace-jump-mode))
#+END_SRC

* COMMENT Editing
#+BEGIN_SRC emacs-lisp
;;CTRLF (pronounced "control F") is an intuitive and efficient
;;solution for single-buffer text search
(use-package ctrlf
 :config (ctrlf-mode))

;; comments
(defun toggle-comment-on-line ()
  "comment or uncomment current line"
  (interactive)
  (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
(global-set-key (kbd "C-;") 'toggle-comment-on-line)

;; Highlights matching parenthesis
(show-paren-mode 1)
#+END_SRC

* Magit
#+BEGIN_SRC emacs-lisp
;; git integration
(use-package magit
  :pin melpa-stable
  :bind ("C-x g" . magit-status))
#+END_SRC

* Org-mode
#+BEGIN_SRC emacs-lisp
(use-package org-bullets)

(use-package org
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c c" . org-capture)
         ("C-c b" . org-iswitchb))
  :init
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

  (setq org-log-done t)
  (setq org-directory "~/org")
  (setq org-agenda-files 
        (list "~/org/work.org"
              "~/org/home.org"
              "~/org/faith.org"))
  (setq org-default-notes-file "~/org/taskdiary.org")

  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-edit-src-content-indentation 0)

  (setq org-capture-templates
    '(("a" "Appointment" entry (file+headling "~/org/taskdiary.org" "Calendar")
       "* APPT %^{Description} %^g
       %?
       Added: %U")
      ("n" "Notes" entry (file+datetree "~/org/taskdiary.org")
       "* %^{Description} %^g 
       %?
       Added: %U")
      ("t" "Tast Diary" entry (file+datetree "~/org/taskdiary.org")
       "* TODO %^{Description} %^g 
       %?
       Added: %U")
      ("j" "Journal" entry (file+datetree "~/org/journal.org")
       "** %^{Heading}")
      ("l" "Log Time" entry (file+datetree "~/org/timelog.org")
       "** %U - %^{Activity} :TIME:")))

  (defun +org/opened-buffer-files ()
    "Return the list of files currently opened in emacs"
    (delq nil
          (mapcar (lambda (x)
                    (if (and (buffer-file-name x)
                             (string-match "\\.org$"
                                           (buffer-file-name x)))
                        (buffer-file-name x)))
                    (buffer-list))))

  (setq org-refile-targets '((+org/opened-buffer-files :maxlevel . 9)))
  (setq org-refile-use-outline-path 'file)
    
  ;; makes org-refile outline working with helm/ivy
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)

  :config
    ;;(use-package org-bullets)
)
#+END_SRC

* Ledger mode
#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :defer t
    :mode ("\\.ledger$" "\\.dat$"))
#+END_SRC

* AUCTeX
#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex
  :init
  (add-hook 'LaTeX-mode-hook #'diatheke-mode)
  (setq-default TeX-engine 'xetex)
  (setq TeX-PDF-mode t)
  (setq TeX-source-correlate-mode t)
  (setq TeX-source-correlate-method '((pdf . synctex)))
  (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
  ;(setq TeXV-view-program-list
  ;     '(("PDF Viewer" "C:/Users/jinair/AppData/Local/SumatraPDF/SumatraPdf.exe mode-io-correlate -forward-search %b %n %o")))
  (eval-after-load "tex"
    '(add-to-list 'TeX-expand-list '("%a" (lambda nil (expand-file-name (buffer-file-name))))))
  (setq TeXV-view-program-list
       '(("PDF Viewer" ("okular --unique %o" (mode-io-correlate "#src:%n%a")))))
  (setenv "PATH" (concat "/Library/TeX/texbin" ":" (getenv "PATH")))

  (add-hook 'LaTeX-mode-hook
            (lambda()
              (add-to-list 'TeX-command-list
                           '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
              (setq TeX-command-default "XeLaTeX")
              (setq TeX-save-query nil)
              (setq TeX-show-compilation t)))

  (add-hook 'LaTeX-mode-hook #'diatheke-mode))
#+END_SRC

* Languages
** Elisp (paredit, eldoc)
*** paredit
;; Automatically load paredit when editing a lisp file
;; More at http://www.emacswiki.org/emacs/ParEdit

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :commands enable-paredit-mode
  :init
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
  :config
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t))
#+END_SRC

*** eldoc-mode
;; eldoc-mode shows documentation in the minibuffer when writing code
;; http://www.emacswiki.org/emacs/ElDoc
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
(add-hook 'ielm-mode-hook 'eldoc-mode)
#+END_SRC

** Clojure (clojure-mode, cider, rainbow-delimeters)
** clojure
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode)

(use-package clojure-mode
  :commands clojure-mode
  :init
  ;; Enable paredit for Clojure
  (add-hook 'clojure-mode-hook #'enable-paredit-mode)
  ;; This is useful for working with camel-case tokens (e.g. JavaClassName)
  (add-hook 'clojure-mode-hook #'subword-mode)
  (add-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
  ;(add-hook 'clojure-mode-hook #'inf-clojure-minor-mode)
  ;; syntax hilighting for midje
  (add-hook 'clojure-mode-hook
            (lambda ()
              (setq inferior-lisp-program "lein repl")
              (font-lock-add-keywords
              nil
              '(("(\\(facts?\\)"
                (1 font-lock-keyword-face))
                ("(\\(background?\\)"
                (1 font-lock-keyword-face))))
                (define-clojure-indent (fact 1))
                (define-clojure-indent (facts 1))))
  :config
  (use-package clojure-mode-extra-font-locking))
#+END_SRC

** cider
#+BEGIN_SRC emacs-lisp
(use-package cider
  :commands cider-jack-in
  :init
  ;; auto completion
  (add-hook 'cider-repl-mode-hook #'company-mode)
  (add-hook 'cider-mode-hook #'company-mode)
  ;; provides minibuffer documentation for the code you're typing into the repl
  (add-hook 'cider-mode-hook 'eldoc-mode)
  ;; enable paredit in your REPL
  (add-hook 'cider-repl-mode-hook 'paredit-mode)
  ;; go right to the REPL buffer when it's finished connecting
  (setq cider-repl-pop-to-buffer-on-connect t)
  ;; When there's a cider error, show its buffer and switch to it
  (setq cider-show-error-buffer t)
  (setq cider-auto-select-error-buffer t)
  ;; Where to store the cider history.
  (setq cider-repl-history-file "~/.emacs.d/cider-history")
  ;; Wrap when navigating history.
  (setq cider-repl-wrap-history t)
  ;; Use clojure mode for other extensions
  (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
  ;;(add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
  (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode)))
#+END_SRC

** Web development (tagedit, emmet-mode, web-mode)
#+BEGIN_SRC emacs-lisp
;; edit html like sexps
(use-package tagedit
  :commands (tagedit-mode tagedit-add-paredit-like-keybindings))

(use-package emmet-mode
  :init
  (add-hook 'clojure-mode-hook 'emmet-mode)
  (add-hook 'sgml-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook 'emmet-mode))

(use-package web-mode
  :init 
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.scss\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)

  ;; Enable line numbers
  ;; set type of line numbering (global variable)
  (setq display-line-numbers-type 'relative) 

  ;; activate line numbering in all buffers/modes
  (global-display-line-numbers-mode)

  ;; change spacing at top of buffer
  (add-to-list 'default-frame-alist '(internal-border-width . 7)))

;; javascript / html
(add-to-list 'auto-mode-alist '("\\.js$" . js-mode))
(add-hook 'js-mode-hook 'subword-mode)
(add-hook 'html-mode-hook 'subword-mode)
(setq js-indent-level 2)
(eval-after-load "sgml-mode"
  '(progn
     (tagedit-add-paredit-like-keybindings)
     (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))))
#+END_SRC


** Rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode)

(use-package cargo
  :hook 
  (rust-mode . cargo-minor-mode))

(use-package racer
  :ensure rust-mode

  :init
  (setq racer-cmd "c:/Users/jinair/.cargo/bin/racer")
  (setq racer-rust-src-path "C:/Users/jinair/.rustup/toolchains/stable-x86_64-pc-windows-msvc/lib/rustlib/src/rust/src")
  (setq company-tooltip-align-annotations t)

  :hook
  (rust-mode . racer-mode)
  (racer-mode . eldoc-mode)
  (racer-mode . company-mode))

#+END_SRC

** GoLang
#+BEGIN_SRC emacs-lisp
(use-package go-mode)

(use-package lsp-mode
  :hook (go-mode . lsp-deferred))
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
(use-package hindent
  :hook
  (haskell-mode . hindent-mode))

(use-package haskell-mode
  :init
  (custom-set-variables
   '(haskell-stylish-on-save t)
   '(haskell-process-suggest-remove-import-lines t)
   '(haskell-process-auto-import-loaded-module t)
   '(haskell-process-log t)
   '(haskell-process-type 'stack-ghci))

  (add-hook 'haskell-mode-hook  
            (lambda ()
              (set (make-local-variable 'company-backends)
                   (append '((company-capf company-dabbrev-code))
                           company-backends))))
  :hook
  (haskell-mode . haskell-auto-insert-module-template)
  (haskell-mode . haskell-collapse-mode)

  :bind
  (("C-`" . haskell-interactive-bring)
   ("C-c C-l" . haskell-process-load-or-reload)
   ("C-c C-c" . haskell-process-cabal-build)
   ("C-c c" . haskell-process-cabal)))
#+END_SRC

* Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 15 ;; takes a while to load, so do it async
  :diminish yas-minor-mode
  :config (yas-global-mode)
  :custom (yas-prompt-functions '(yas-completing-prompt)))
#+END_SRC
